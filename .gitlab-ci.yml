stages:          # List of stages for jobs, and their order of execution
  - checkout
  - build
  - buildimgs
  - deploy
variables:
  COMMIT_REF: "${CI_COMMIT_BRANCH}"
  WORK_DIR: '/home/gitlab-runner/workspace'
workflow:
  rules:
    - if: "$CI_COMMIT_BRANCH == 'test'"
      variables:
        ENV: 'test'
        BRANCH: 'test'
    - if: "$CI_COMMIT_BRANCH == 'main'"
      variables:
        ENV: 'prod'
        BRANCH: 'main'
    - if: $CI_COMMIT_TAG
      variables:
        ENV: 'prod'
        BRANCH: 'main'
ä»£ç æ£€å‡º:
  stage: checkout
  script:
    - cd ${WORK_DIR}/${ENV}
    - echo "æ­£åœ¨æ¸…ç†å·¥ä½œåŒºğŸ§¹â€¦â€¦" && rm -rf ${CI_PROJECT_NAME}
    - git init
    - git config user.name "${UV_DEVOPS_USER}"
    - git config user.password "${UV_DEVOPS_PAT}"
    - git config credential.helper store
    - echo "å½“å‰åˆ†æ”¯ï¼š${CI_COMMIT_BRANCH}"
    - echo -e "æ­£åœ¨å‡†å¤‡ä»è¿œç«¯ä»“åº“æ‹‰å–ä»£ç â€¦â€¦" 
    - time git clone -b ${BRANCH} ${CI_REPOSITORY_URL}
    - sleep 3
    - cd ${WORK_DIR}/${ENV}/${CI_PROJECT_NAME}
    - |
      if  [ ${ENV} == 'prod' ];then
        PREVIOUS_VERSION=`git describe --tags --abbrev=0 $(git rev-parse --abbrev-ref HEAD)~1 --always`
        if [ -z ${PREVIOUS_VERSION} ];then
          PREVIOUS_VERSION='v1.0.0'
        fi
      elif [ ${ENV} == 'test' ];then
        PREVIOUS_VERSION=`git log -n 2 --format=%cd --skip=2|awk 'NR==2{print $0}'|sed 's/:/-/g'|sed 's/ /-/g'|sed 's/+/-/g'`
      fi
      echo "PREVIOUS_VERSION=${PREVIOUS_VERSION}" >> cicd.env
    # - echo "ä¸Šä¸ªç‰ˆæœ¬ä¸ºï¼š${PREVIOUS_VERSION}"
    - |
      if [ ${ENV} == 'prod' ];then
        CURRENT_VERSION=`git describe --tags $(git rev-list --tags --max-count=1)`
      elif [ ${ENV} == 'test' ];then
        CURRENT_VERSION=`echo "${CI_COMMIT_TIMESTAMP}"|sed 's/:/-/g'|sed 's/+/-/g'`
      fi
      echo "CURRENT_VERSION=${CURRENT_VERSION}" >> cicd.env
    - echo -e "å½“å‰ç‰ˆæœ¬ä¸ºï¼š\033[1;31m${CURRENT_VERSION}\033[0m" 
    - echo -e "ä¸Šä¸€ä¸ªç‰ˆæœ¬ä¸ºï¼š\033[1;31m${PREVIOUS_VERSION}\033[0m" 
    - COMMIT_TIME=$(git log -1 --format=%cd)
    - echo "$CI_COMMIT_TIMESTAMP"
    - echo "COMMIT_TIME:${COMMIT_TIME}"
    - echo -e "å½“å‰ç‰ˆæœ¬çš„æäº¤ä¿¡æ¯ä¸ºï¼š\033[1;31m${CI_COMMIT_MESSAGE}\033[0m"
    - echo -e "å½“å‰ç‰ˆæœ¬çš„æäº¤è€…ä¸ºï¼š${CI_COMMIT_AUTHOR}"
    - echo -e "å½“å‰ç‰ˆæœ¬çš„SHAä¸ºï¼š\033[1;31m${CI_COMMIT_SHA}\033[0m"
    - if [ ${ENV} == 'prod' ];then git fetch --tags;fi
    - if [ ${ENV} == 'prod' ];then git checkout tags/$CI_COMMIT_TAG;fi
  only:
    - tags
    - test
  tags:
    - runner4

è¯­è¨€æ£€æµ‹:
  stage: build
  script:
    - cd ${WORK_DIR}/${ENV}/${CI_PROJECT_NAME}
    - CURRENT_VERSION=`grep 'CURRENT_VERSION' cicd.env |awk -F = '{print $2}'`
    - LANGUAGE=$(echo ${CI_PROJECT_REPOSITORY_LANGUAGES}|awk -F , '{print$1}' | tr '[:lower:]' '[:upper:]') && echo "LANGUAGE=${LANGUAGE}" >> cicd.env
    - echo -e "æ£€æµ‹åˆ°å½“å‰ä»“åº“ä¸»è¦çš„ç¼–ç¨‹è¯­è¨€æ˜¯ï¼š\033[1;31m ${LANGUAGE} \033[0mï¼Œå³å°†è¿›å…¥ \033[1;31m ${LANGUAGE} \033[0m é¡¹ç›®æ„å»ºé˜¶æ®µâ€¦â€¦"
    - echo "${CURRENT_VERSION}"
  variables:
    GIT_CHECKOUT: false
  only:
    - tags
    - test
  tags:
    - runner4
é¡¹ç›®æ„å»º:
  stage: build
  needs:
    - job: "ä»£ç æ£€å‡º"
  script:
    - cd ${WORK_DIR}/${ENV}/${CI_PROJECT_NAME}
    - LANGUAGE=`grep 'LANGUAGE' cicd.env |awk -F = '{print $2}'`
    - CURRENT_VERSION=`grep 'CURRENT_VERSION' cicd.env |awk -F = '{print $2}'`
    - echo -e "å½“å‰ä»“åº“çš„æœ€æ–°ç‰ˆæœ¬ä¸ºï¼š\033[1;31m ${CURRENT_VERSION} \033[0m"
    - if [ ${LANGUAGE} == 'PHP' ];then echo -e "å½“å‰è¯­è¨€ä¸ºè§£é‡Šæ€§è¯­è¨€ï¼Œæ— éœ€é¢„ç¼–è¯‘ï¼Œå³å°†è¿›å…¥ä¸‹ä¸€é˜¶æ®µJOBâ€¦â€¦";fi
  variables:
    GIT_CHECKOUT: false
  only:
    - tags
    - test
  tags:
    - runner4
æ„å»ºé•œåƒ:
  stage: buildimgs
  needs:
    - job: "é¡¹ç›®æ„å»º"
  script:
    - cd ${WORK_DIR}/${ENV}/${CI_PROJECT_NAME}
    - CURRENT_VERSION=`grep 'CURRENT_VERSION' cicd.env |awk -F = '{print $2}'`
    - echo -e "å½“å‰é¡¹ç›®é…ç½®çš„ç§æœ‰é•œåƒä»“åº“ä¸ºï¼š\033[1;31m ${UV_HARBOR_HOST} \033[0mï¼Œæœ¬æ¬¡æ„å»ºçš„é•œåƒå°†æ¨é€è‡³è¯¥ä¸»æœºâ€¦â€¦"
    - echo ${CURRENT_VERSION}
    - time sudo docker build -f Dockerfile -t ${UV_HARBOR_HOST}/${CI_PROJECT_NAMESPACE}/${ENV}/${CI_PROJECT_NAME}:${CURRENT_VERSION} .
    - time sudo docker build -f Dockerfile -t ${UV_HARBOR_HOST}/${CI_PROJECT_NAMESPACE}/${ENV}/${CI_PROJECT_NAME}:latest .
    - echo -e "é•œåƒ\033[1;31m${UV_HARBOR_HOST}/${CI_PROJECT_NAMESPACE}/${ENV}/${CI_PROJECT_NAME}:${CURRENT_VERSION}\033[0må·²æˆåŠŸæ„å»ºğŸ…"
  variables:
    GIT_CHECKOUT: false
  only:
    - tags
    - test
  tags:
    - runner4  
æ¨é€é•œåƒ:
  stage: buildimgs
  needs:
    - job: "æ„å»ºé•œåƒ"
  script:
    - cd ${WORK_DIR}/${ENV}/${CI_PROJECT_NAME}
    - CURRENT_VERSION=`grep 'CURRENT_VERSION' cicd.env |awk -F = '{print $2}'`
    - sudo docker login -u ${UV_HARBOR_USER} -p ${UV_HARBOR_PWD} ${UV_HARBOR_HOST}
    - echo  ${CURRENT_VERSION}
    - time sudo docker push ${UV_HARBOR_HOST}/${CI_PROJECT_NAMESPACE}/${ENV}/${CI_PROJECT_NAME}:${CURRENT_VERSION}
    - time sudo docker push ${UV_HARBOR_HOST}/${CI_PROJECT_NAMESPACE}/${ENV}/${CI_PROJECT_NAME}:latest
    - echo -e "é•œåƒ\033[1;31m${UV_HARBOR_HOST}/${CI_PROJECT_NAMESPACE}/${ENV}/${CI_PROJECT_NAME}:${CURRENT_VERSION}\033[0må·²æˆåŠŸæ¨é€åˆ°ç§æœ‰ä»“åº“ğŸ…"
  variables:
    GIT_CHECKOUT: false
  only:
    - tags
    - test
  tags:
    - runner4
æ¸…ç†æœ¬åœ°é•œåƒ:
  stage: buildimgs
  needs:
    - job: "æ„å»ºé•œåƒ"
  script:
    - cd ${WORK_DIR}/${ENV}/${CI_PROJECT_NAME}
    - CURRENT_VERSION=`grep 'CURRENT_VERSION' cicd.env |awk -F = '{print $2}'`
    - echo  ${CURRENT_VERSION}
    - time sudo docker rmi ${UV_HARBOR_HOST}/${CI_PROJECT_NAMESPACE}/${ENV}/${CI_PROJECT_NAME}:${CURRENT_VERSION}
    - time sudo docker rmi ${UV_HARBOR_HOST}/${CI_PROJECT_NAMESPACE}/${ENV}/${CI_PROJECT_NAME}:latest
    - echo -e "é•œåƒ\033[1;31m${UV_HARBOR_HOST}/${CI_PROJECT_NAMESPACE}/${ENV}/${CI_PROJECT_NAME}:${CURRENT_VERSION}\033[0må·²ä»æœ¬åœ°é•œåƒåº“æ¸…ç†ğŸ§¹"
  variables:
    GIT_CHECKOUT: false
  only:
    - tags
    - test
  tags:
    - runner4

ä¿®æ”¹Chartsæ¨¡æ¿:
  stage: deploy
  needs:
    - job: "æ„å»ºé•œåƒ"
  script:
    - cd ${WORK_DIR}/${ENV}/${CI_PROJECT_NAME}
    - PREVIOUS_VERSION=`cat cicd.env |grep PREVIOUS_VERSION|awk -F = '{print $2}'`
    - CURRENT_VERSION=`grep 'CURRENT_VERSION' cicd.env |awk -F = '{print $2}'`
    - echo "æ­£åœ¨å‡†å¤‡ä»è¿œç¨‹ä»“åº“è·å–Chartsæ¨¡æ¿ï¼Œè¯·ç¨åâŒ›ï¸"
    - helm registry login ${UV_HARBOR_HOST} -u ${UV_HARBOR_USER} -p ${UV_HARBOR_PWD}
    - if [ ${ENV} == 'prod' ];then CHART_ENV='prod';else CHART_ENV='test';fi
    - |
      for i in ${CHART_ENV};do
        helm pull oci://${UV_HARBOR_HOST}/charts/${i}/${CI_PROJECT_NAME} --untar
        echo "${i}ç¯å¢ƒçš„Chartsæ¨¡æ¿å·²æˆåŠŸè·å–ğŸ…"
        CHART_VERSION=$(grep '^version' ${CI_PROJECT_NAME}/Chart.yaml | awk -F : '{print $2}')
        echo "å½“å‰Jobä»è¿œç¨‹ä»“åº“è·å–çš„Chartsçš„ç‰ˆæœ¬å·ä¸ºï¼š${CHART_VERSION}"
        # Chartsç‰ˆæœ¬å·è‡ªåŠ¨é€’å¢â¬‡ï¸
        major=$(echo ${CHART_VERSION} | cut -d '.' -f 1)
        minor=$(echo ${CHART_VERSION} | cut -d '.' -f 2)
        patch=$(echo ${CHART_VERSION} | cut -d '.' -f 3)
        if ! [[ ${major} =~ ^[0-9]+$ ]] || ! [[ ${minor} =~ ^[0-9]+$ ]] || ! [[ ${patch} =~ ^[0-9]+$ ]] ; then 
          echo "Invalid version format" 
          exit
        fi
        patch=$((patch + 1))
        if [ ${patch} -gt 99 ]; then 
          patch=0 minor=$((minor + 1))
          if [ ${minor} -gt 99 ]; then
            minor=0 major=$((major + 1))
          fi
        fi
        NEW_CHART_VERSION=$major.$minor.$patch
        echo "æ–°ç”Ÿæˆçš„Chartsç‰ˆæœ¬ä¸º:${NEW_CHART_VERSION}" && echo "NEW_CHART_VERSION-${i}=${NEW_CHART_VERSION}" >> cicd.env
        sed -i "s#^environment.*#environment: ${i}#g" ${CI_PROJECT_NAME}/values.yaml
        sed -i "s#^currentAppVersion.*#currentAppVersion: ${CURRENT_VERSION}#g" ${CI_PROJECT_NAME}/values.yaml
        sed -i "s#^previousAppVersion.*#previousAppVersion: ${PREVIOUS_VERSION}#g" ${CI_PROJECT_NAME}/values.yaml
        sed -i "s#^appVersion.*#appVersion: ${CURRENT_VERSION}#g" ${CI_PROJECT_NAME}/Chart.yaml
        sed -i "s#^version.*#version: ${NEW_CHART_VERSION}#g" ${CI_PROJECT_NAME}/Chart.yaml
        IMG_TAG="`cat ${CI_PROJECT_NAME}/values.yaml|grep '  tag'`"
        echo "IMG_TAGä¸ºï¼š${IMG_TAG}"
        sed -i "s#${IMG_TAG}#  tag: ${CURRENT_VERSION}#g" ${CI_PROJECT_NAME}/values.yaml
        helm package ${CI_PROJECT_NAME}
        echo "æ­£åœ¨å°†${i}ç¯å¢ƒçš„ChartsåŒ…åŒæ­¥è‡³è¿œç¨‹ä»“åº“ï¼Œè¯·ç¨åâŒ›ï¸"
        helm push ${CI_PROJECT_NAME}-${NEW_CHART_VERSION}.tgz oci://${UV_HARBOR_HOST}/charts/${i}
        echo "${i}ç¯å¢ƒçš„Chartsæ¨¡æ¿å·²ç»æˆåŠŸåŒæ­¥è‡³è¿œç¨‹ä»“åº“ğŸ…"
        rm -rf ${CI_PROJECT_NAME}*
      done
  variables:
    GIT_CHECKOUT: false
  only:
    - tags
    - test
  tags:
    - runner4
  # when: manual


éƒ¨ç½²åˆ°æµ‹è¯•ç¯å¢ƒ:
  stage: deploy
  needs:
    - job: "ä¿®æ”¹Chartsæ¨¡æ¿"
  script:
    - cd ${WORK_DIR}/${ENV}/${CI_PROJECT_NAME}
    - NEW_CHART_VERSION=`grep 'NEW_CHART_VERSION-test' cicd.env |awk -F = '{print $2}'`
    - argocd-cli login ${UV_ARGOCD_HOST} --username admin --password ${UV_ARGOCD_PWD} --grpc-web
    - argocd-cli app set ${ENV}-${CI_PROJECT_NAME} --parameter replicaCount=1 --grpc-web
    - |
      argocd-cli app patch ${ENV}-${CI_PROJECT_NAME} --patch '{"spec": { "source": { "targetRevision": "'${NEW_CHART_VERSION}'" } }}' --type merge --grpc-web
    - argocd-cli app get ${ENV}-${CI_PROJECT_NAME} --hard-refresh --grpc-web
    - argocd-cli app sync ${ENV}-${CI_PROJECT_NAME} --revision ${NEW_CHART_VERSION} --grpc-web --apply-out-of-sync-only --async
    - echo "å·²åŒæ­¥ç‰ˆæœ¬ä¸º${NEW_CHART_VERSION}çš„Chartsæ¨¡æ¿æ–‡ä»¶ï¼Œæ­£åœ¨åå°æ‰§è¡Œéƒ¨ç½²ä»»åŠ¡ï¼Œå®Œå…¨ç”Ÿæ•ˆå¯èƒ½éœ€è¦ä¸€åˆ°ä¸¤åˆ†é’Ÿï¼Œè¯·è€å¿ƒç­‰å¾…åº”ç”¨éƒ¨ç½²âŒ›ï¸"
  variables:
    GIT_CHECKOUT: false
  only:
    - test
  tags:
    - runner4

å…³é—­æµ‹è¯•ç¯å¢ƒ:
  stage: deploy
  needs:
    - job: "ä¿®æ”¹Chartsæ¨¡æ¿"
  script:
    - cd ${WORK_DIR}/${ENV}/${CI_PROJECT_NAME}
    - NEW_CHART_VERSION=`grep 'NEW_CHART_VERSION-test' cicd.env |awk -F = '{print $2}'`
    - argocd-cli login ${UV_ARGOCD_HOST} --username admin --password ${UV_ARGOCD_PWD} --grpc-web
    - argocd-cli app set ${ENV}-${CI_PROJECT_NAME} --parameter replicaCount=0 --grpc-web
    - argocd-cli app sync ${ENV}-${CI_PROJECT_NAME} --revision ${NEW_CHART_VERSION} --grpc-web --apply-out-of-sync-only --async
    - echo "æ­£åœ¨å°†æµ‹è¯•ç¯å¢ƒçš„Podå‰¯æœ¬æ•°é‡è°ƒæ•´ä¸º0ï¼Œè¯·ç¨åâŒ›ï¸"
    - echo "æœ¬æ¬¡ä»»åŠ¡æ“ä½œè€…ä¸ºï¼š${GITLAB_USER_NAME}"
  variables:
    GIT_CHECKOUT: false
  only:
    - test
  tags:
    - runner4
  when: manual

éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ:
  stage: deploy
  needs:
    - job: "ä¿®æ”¹Chartsæ¨¡æ¿"
  script:
    - cd ${WORK_DIR}/${ENV}/${CI_PROJECT_NAME}
    - NEW_CHART_VERSION=`grep 'NEW_CHART_VERSION-prod' cicd.env |awk -F = '{print $2}'`
    - argocd-cli login ${UV_ARGOCD_HOST} --username admin --password ${UV_ARGOCD_PWD} --grpc-web
    - |
      argocd-cli app patch ${ENV}-${CI_PROJECT_NAME} --patch '{"spec": { "source": { "targetRevision": "'${NEW_CHART_VERSION}'" } }}' --type merge --grpc-web
    - argocd-cli app get ${ENV}-${CI_PROJECT_NAME} --hard-refresh --grpc-web
    - argocd-cli app sync ${ENV}-${CI_PROJECT_NAME} --revision ${NEW_CHART_VERSION} --grpc-web --apply-out-of-sync-only --async
    - echo "å·²åŒæ­¥ç‰ˆæœ¬ä¸º${NEW_CHART_VERSION}çš„Chartsæ¨¡æ¿æ–‡ä»¶ï¼Œæ­£åœ¨åå°æ‰§è¡Œéƒ¨ç½²ä»»åŠ¡ï¼Œå®Œå…¨ç”Ÿæ•ˆå¯èƒ½éœ€è¦ä¸€åˆ°ä¸¤åˆ†é’Ÿï¼Œè¯·è€å¿ƒç­‰å¾…åº”ç”¨éƒ¨ç½²âŒ›ï¸"
    - echo "æœ¬æ¬¡ä»»åŠ¡æ“ä½œè€…ä¸ºï¼š${GITLAB_USER_NAME}"
  variables:
    GIT_CHECKOUT: false
  only:
    - tags
  tags:
    - runner4
  when: manual